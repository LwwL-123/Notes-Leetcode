# 双指针



## 1. 快慢指针

### [剑指 Offer II 022. 链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)

判断链表中是否有环，并且换回这个环的起始位置

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    var slow,fast  *ListNode
    hasCircle := false
    slow = head
    fast = head

    for (fast != nil && fast.Next != nil) {
        slow = slow.Next
        fast = fast.Next.Next

        if fast == slow {
            hasCircle = true
            break
        }
    }

    if hasCircle {
        slow = head 
        for slow != fast {
            slow = slow.Next
            fast = fast.Next
        }
        return slow
    }else {
        return nil
    }

}
```



### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

让快指针先走k步，后快慢指针同步，最后返回慢指针

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getKthFromEnd(head *ListNode, k int) *ListNode {
    var slow, fast *ListNode
    slow  = head
    fast = head 

    // 让快指针先走k步
    for i:=0;i<k;i++ {
        fast = fast.Next
    }

    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```



## 2. 左右指针

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```go
func search(nums []int, target int) int {
    left := 0 
    right := len(nums) -1 
    var mid int

    for (left <= right) {
        mid = (left + right) / 2
        if nums[mid] == target {
            return mid
        }else if nums[mid] < target{
            left = mid + 1
        }else{
            right = mid -1 
        }
    }
    return -1 
}
```





# 滑动窗口



## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

例:  

s "qwerllllwr" 

t = "wr"

输出为: "wr" 

```go
func minWindow(s string, t string) string {

	window := make(map[byte]int,0)
	need := make(map[byte]int,0)

	for i := range t {
		need[t[i]]++
	}

	left,right,match :=0,0,0
	// 记录最小覆盖子串的起始索引及长度
	start,end := 0,0
	min := len(s) + 1

	for right < len(s) {
		// 将s[right]加入，形成(left,right]
		ch1 := s[right]
		window[ch1]++

		// 右移窗口
		right++

		// 更新状态
		if window[ch1] == need[ch1] {
			match++
		}

		// 判断左侧窗口是否需要收缩
		for match == len(need) {
			// 更新最小覆盖子串
			if right -left < min {
				start,end = left,right
				min = right -left
			}

			// 获取将要移出窗口的字符
			ch2 := s[left]
			left++

			// 更新状态
			if window[ch2] == need[ch2] {
				match--
			}
			window[ch2]--
		}
	}

	return s[start:end]
}
```

