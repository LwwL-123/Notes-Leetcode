# 动态规划

### 动态规划步骤:

1. 明确dp数组含义
2. 定义base case
3. 找状态转移方程



### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

即为标准的LIS的长度

![图片.png](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211207174911.png)

```go
func lengthOfLIS(nums []int) int {
    
    dp := make([]int,len(nums))
    res := 1
    for i := 0; i < len(nums); i++ {
        dp[i] = 1 
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i],dp[j]+1)
            }
        }
        res = max(res,dp[i])
    }
    
    return res
}

func max(a,b int) int {
    if a > b {
        return a 
    }else {
        return b
    }
}
```



### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

先对宽度w进行升序排序，如果遇到w相同的情况，则按照高度h降序排序。之后吧所有的h作为一个数组，在这个数组上计算出标准的LIS的长度

```go
func maxEnvelopes(envelopes [][]int) int {

    // 排序
    sort.Slice(envelopes, func(i, j int) bool {
		if envelopes[i][0] < envelopes[j][0] {
			return true
		}else if envelopes[i][0] == envelopes[j][0]{
			if envelopes[i][1] > envelopes[j][1] {
				return true
			}else {
				return false
			}
		}else {
			return false
		}
	})

    var height []int
    for i := range envelopes {
        height = append(height,envelopes[i][1])
    }

    dp := make([]int,len(height))
    res := 1

    for i := 0; i < len(height); i++ {
        dp[i] = 1 
        for j:=0; j < i; j++ {
            if height[i] > height[j] {
                dp[i] = max(dp[i],dp[j]+1)
            }
        }
        res = max(res,dp[i])
    }

    return res
}

func max(a,b int) int {
    if a > b {
        return a 
    }else {
        return b
    }

}
```



#### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```go
func maxSubArray(nums []int) int {
    dp := make([]int,len(nums))

    dp[0] = nums[0]

    for i:=1;i<len(nums);i++ {
        if dp[i-1] > 0 {
            dp[i] = dp[i-1] + nums[i]
        }else {
            dp[i] = nums[i]
        }
    }

    res := dp[0]
    for i:= range dp {
        if dp[i] > res {
            res = dp[i]
        }
    }

    return res
}
```



## 经典二维动态规划

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

![image-20211214111327915](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211214111328.png)

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    len1 := len(text1)
    len2 := len(text2)
    dp := make([][]int,len1+1)
    for i := range dp {
        dp[i] = make([]int,len2+1)
    }

    for i := 1; i <= len1; i++ {
        for j := 1; j <= len2; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1 
            }else {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1])
            }
        }
    }

    return dp[len1][len2]
}

func max(a,b int) int {
    if a > b {
        return a 
    }else {
        return b
    }
}
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

**dp[i]\[j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i]\[j]**。

```
            a                       
   +-----+-----+             
   |  0  |  1  |           
   +-----+-----+       
 a |  1  |  0  |          
   +-----+-----+ 
 d |  2  |  1  |
   +-----+-----+

```

```go
func minDistance(word1 string, word2 string) int {
    len1, len2 := len(word1),len(word2)
    dp := make([][]int,len1 + 1)
    // 初始化dp
    for i := range dp {
        dp[i] = make([]int,len2 + 1)
    }
    for i := 0; i < len1 + 1; i++ {
        dp[i][0] = i
    }
    for j := 0; j < len2 + 1; j++ {
        dp[0][j] = j
    }

    for i := 1; i < len1 + 1; i++ {
        for j := 1 ; j < len2 + 1; j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            }else {
                dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1
            }
        }
    } 

    return dp[len1][len2]
}   

func min(args ...int) int {
    min := args[0]
    for _,i := range args {
        if i < min {
            min = i
        }
    }
    return min
}
```





#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

![image.png](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211217103119.png)

```go
func countSubstrings(s string) int {
    length := len(s) 
    var count int
    dp := make([][]bool,length)

    for i := range dp {
        dp[i] = make([]bool,length)
        dp[i][i] = true
        count++
    }

    for i := length - 2; i >=0; i-- {
        for j := i + 1; j < length; j++ {
            if s[i] == s[j] {
                if j - i == 1 {
                    dp[i][j] = true
                    count++
                }else if dp[i+1][j-1] == true {
                    dp[i][j] = true
                    count++
                }
            }else {
                dp[i][j] = false
            }
        }
    }

    return count

}
```





#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

![image-20211216180531653](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211216180531.png)

```go
func longestPalindromeSubseq(s string) int {
    length := len(s)
    dp := make([][]int,length)

    for i := range dp {
        dp[i] = make([]int,length)
        dp[i][i] = 1
    }

    for i := length-2; i >= 0; i-- {
        for j := i+1; j < length;j++ {
            if s[i] == s[j] {
                dp[i][j] = dp[i+1][j-1] + 2 
            }else {
                dp[i][j] = max(dp[i+1][j],dp[i][j-1])
            }
        }
    }    

    return dp[0][length-1]
}

func max(a,b int) int {
    if a > b {
        return a
    }else {
        return b
    }
}
```

#### [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

```go
func minInsertions(s string) int {
    length := len(s)
    dp := make([][]int, length)

    for i := range dp {
        dp[i] = make([]int,length)
        dp[i][i] = 0
    }

    for i := length - 2; i >= 0; i-- {
        for j := i + 1; j < length; j++ {
            if s[i] == s[j] {
                dp[i][j] = dp[i+1][j-1]
            }else {
                dp[i][j] = min(dp[i+1][j],dp[i][j-1]) + 1
            }
        }
    }

    return dp[0][length-1]
}

func min(a,b int) int {
    if a > b {
        return b
    }else {
        return a 
    }
}
```

